\section{Introduction}

\subsection{Color gamuts}
There are several issues involved in reproducing colors from one device on another.
One important of these is the range of colors an imaging device, such as a camera, printer or monitor, is able to capture or provide.
Take for example an outdoor scene captured with a digital camera.
The camera will have a limited range of colors it can capture, so it can't capture the exact look of the real scene.
If someone then wants to display the image on a monitor, that monitor will have a limited range of colors that it can provide, so it might not be able to reproduce the same look as the camera captured.
This range of a set of colors that a device can reproduce is the color gamut~\cite{GamutMapping,HandbookGamutMapping}.

Since the colors can be represented in a three-dimensional space, the color gamut can as well.
This means that a color gamut has a volume and a surface, meaning that it is a three-dimensional mesh.
This surface, which is \say{determined by a color gamut's extremities}~\cite{ColourImageScience}, is what is referred to as the gamut boundary, which is described by a gamut boundary descriptor (GBD)~\cite{HandbookGamutMapping}.

\subsection{Visualization of gamut boundaries}
\label{sec:intro-gbd-viz}
Because of the issues with color gamut and color gamut mapping, the need for visualizing the gamut of media appeared~\cite{InteractiveGamutMapping}.
Visualizing color gamuts would allow people a better understanding the gamuts and issues involved.
By visually displaying a color gamut, a human can intuitively see which color areas are outside or inside the gamut boundaries.
Even more intuitevely a person can compare two color gamuts visually and determine which colors of one gamut is outside another.
This can help understanding why an image doesn't appear right on a device and what needs to be done to map from one gamut to another in a pleasing or correct way.

There are multiple ways of visualizing a gamut, in both two and three-dimensional spaces~\cite{ColourImaging,InteractiveGamutMapping}.
Because colors can be represented in a three-dimensional space, three-dimensional visualizations properly represent the color gamut.
Two-dimensional gamuts have to remove one dimension or simplify the problem in another way~\cite{InteractiveGamutMapping}.
Still, they are very much used, mainly because the whole visualization can be shown as one single image on paper or a monitor.
One of the more popular two-dimensional visualizations is the xy chromaticity diagram.
For three-dimensional visualizations a mesh or scatterplot in CIELAB is most commonly used since CIELAB is three-dimensional (L*a*b*).

\subsection{Gamut boundary encoding in iccMAX}
The International Color Consortium (ICC) have created a standard specification image technology color management which includes an architecture, profile format and datastructure~\cite{ColorManagement}.
The profile format allows manufactureres to create standard conforming profiles that define input or output characterizations.
There are several versions of the ICC specificatio, with iccMAX being the 5th and latest version.~\cite{IccMax}
The specification of iccMAX is currently in preliminary form, available for the public.
It introduces many improvements, like flexible illuminant and color matching function and a new GBD.
This goal of this project is to visualize this new GBD.

\subsection{Cross-platform and open source}
\label{sec:crossplatform-open}
One of the goals of this project is to to only rely on open source projects, preferably with a noncopylefted license~\cite{GnuFreeCategories}.
In addition the project itself will be released as noncopyledted open source software licensed under the MIT license~\cite{MitLicense}.
There are many benefits of using and publishing open source software.
Most importantly the software can be used by everyone without worrying about licensing restrictions.
But open source also makes the software easier to maintain, inspires derivations and extensions.

In addition, this project will be built for cross-platform usage.
It is a fact today that many different platforms are used, from PC platforms such as Windows, Mac OS X and Linux, to mobile platforms such as Android and iPhone/iPad.
It is important that the software is available on all of these platforms so that as few users as possible are left out.
An additional requirement is that the software should without much effort work on new emerging platforms for a lonig-lasting life.

\section{Methods}

\subsection{Platform and technologies}
To meet the requirements in Section~\ref{sec:crossplatform-open}, proper platform and technologies to build the application on have to be selected.
There are several good platforms available to use today.
One alternative is to write a native desktop application using cross-platform GUI toolkits, but this would mean compiling one version for each of the supported platforms, which will result in extra overhead.
Another alternative is using a virtualized platform such as Java, but Java is seeing less support as a GUI front end and is not supported on all platforms (e.g.\ iPhone/iPad).
While there are more alternatives, they have mostly the same limitatations.
What remains then is the web platform.
It is an open platform, it is supported by all major operating systems with a proper GUI, it supports hardware accelerated graphics, and the same source code will work on all browsers.
One might think that it would require an active internet connection, but in fact a website can work offline as well.
It can even be wrapped in another application including an internal web browser.
Thus the open web platform was selected as the base for building the application.

To allow faster development, while still having an appealing interface, the Boostrap library was used~\cite{Bootstrap}.
To make the application dynamic and reactive the AngularJS library was used~\cite{Angular}.
Both of these conform to web standards and work on many different browsers and versions.
To allow for easier builds, which helps user and developer adoption, the popular and freely available Grunt build system together with npm as a dependency installer was used~\cite{Grunt,Npm}.

\subsection{Parsing the GBD from iccMAX profiles}
The application consists of two major parts: GBD parsing and GBD visalization.
Since ICC Profiles use a binary format, a binary profile parser was written.
It was based on the preliminary specification of iccMAX, so any iccMAX Profile will be parsed correctly as long as the specification do not change.
The application searches through the Profile tag list until it finds the gbd0 tag, which is \say{the gamut boundary of the reference medium gamut that was used for the creation of the perceptual transform}~\cite{IccMaxSpec}.
This tag and gbd1, gbd2 and gbd3 is of type gamutBoundaryDescriptionType.
The implementation can easily be extended to also parse the other GBD tags.
The GBD tag type is specified precisely in the specification, and the implementation follows this to the point.

Finally, the GBD tag data required to visualize the gamut (faces and PCS vertices) plus the PCS spaced is stored in a JavaScript structure to later be parsed by the visualizer.

\subsection{Visualizing the gamut bondary}
The first major part of the application was the GBD parsing.
With the GBD data now parsed, the second major part, GBD visualization, can take place.
As discussed in Section~\ref{sec:intro-gbd-viz}, there exists several methods of visualizing gamut.
Since most consumer computers can now handle 3D graphics well, the development platform supports 3D hardware acceleration, and 3D visualization is the most proper GBD visualization, a CIELAB space 3D visualization was selected for the first implementation.
Other visualizations could be added at a later time.

To fully utilize 3D hardware rendering, WebGL was used.
But raw WebGL code is not easy nor fast to write, so a third party library called three.js was picked to handle the WebGL 3D rendering.

The rendering implementation uses Model Makers that can be extended, to create the 3D visualized models.
E.g.\ Point Model Maker and Solid Model Maker are extending the basic Model Maker to create a point and solid model respectively.
This system allows for switching between visualizations and extending with different visualizations at a later time.



\section{Results}
\begin{itemize}
	\item Show screenshots with sRGB gamut example
\end{itemize}

\section{Analysis}
\begin{itemize}
	\item Discuss how well it works
	\item Discuss correctness
	\item Discuss issues
	\item Discuss extensibility
\end{itemize}

\section{Conclusions}
It's good, man

